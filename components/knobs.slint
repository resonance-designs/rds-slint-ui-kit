import { Theme } from "../theme/index.slint";

/*
Component: RDSKnob
Description: A rotary knob component that supports both bounded and infinite rotation modes.
Public properties:
- value: float - Current value
- rotation-angle: angle - Current rotation angle
- size: length - Size of the knob (width and height)
- indicator-position: length - Distance from center to indicator (radius)
- sensitivity: float - Adjust this to change rotation speed
- scroll-sensitivity: float - Sensitivity for scroll wheel
- min-value: float - Minimum value (set equal to max-value for infinite mode)
- max-value: float - Maximum value (set equal to min-value for infinite mode)

Example usage:

RDSKnob {
    size: 60px;
    indicator-position: 20px;
    sensitivity: 0.8;
    min-value: 0;
    max-value: 127;
}
*/
export component RDSKnob inherits Rectangle {
    // Public properties
    in-out property <float> value: 0; // Current value
    in-out property <angle> rotation-angle: 0deg; // Current rotation angle
    in-out property <length> size: 60px; // Size of the knob (width and height)
    in-out property <length> indicator-position: 15px; // Distance from center to indicator (radius)
    in-out property <float> sensitivity: 0.5; // Change rotation speed
    in-out property <float> scroll-sensitivity: 1.0; // Sensitivity for scroll wheel

    // Range properties - set min-value == max-value for infinite mode
    in-out property <float> min-value: 0;
    in-out property <float> max-value: 0; // 0 means infinite (or set equal to min-value)

    callback value-changed(float); // Callback when value changes

    // Private properties for drag tracking
    private property <length> drag-start-y: 0px;
    private property <float> drag-start-value: 0;

    // Helper property to check if infinite mode
    private property <bool> is-infinite: root.min-value == root.max-value;

    width: root.size;
    height: root.size;
    background: @linear-gradient(180deg, Theme.active.background_raised 0%, Theme.active.background_main 100%);
    border-radius: root.width / 2;
    border-width: 2px;
    border-color: @linear-gradient(180deg, Theme.active.border_strong 0%, Theme.active.background_main 100%);

    // Position/value indicator - size scales with knob size
    indicator := Rectangle {
        width: root.size / 6; // Proportional to knob size
        height: root.size / 6;
        // Calculate position based on rotation angle and indicator-position
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: @linear-gradient(180deg, Theme.active.background_main 0%, Theme.active.background_raised 100%);
        border-radius: self.width / 2;
        border-width: 1px;
        border-color: @linear-gradient(180deg, Theme.active.background_main 0%, Theme.active.border_strong 100%);
    }

    // Touch area for interaction
    touch := TouchArea {
        pointer-event(event) => {
            if (event.button == PointerEventButton.left) {
                if (event.kind == PointerEventKind.down) {
                    root.drag-start-y = self.mouse-y;
                    root.drag-start-value = root.value;
                }
            }
        }

        moved => {
            if (self.pressed) {
                // Calculate delta from drag start (convert length to float by dividing by 1px)
                root.value = root.drag-start-value + (root.drag-start-y - self.mouse-y) / 1px * root.sensitivity;

                // Clamp value if in bounded mode
                if (!root.is-infinite) {
                    root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
                }

                // Convert value to rotation angle
                if (root.is-infinite) {
                    // Infinite rotation
                    root.rotation-angle = root.value * 1deg;
                } else {
                    // Bounded rotation: map value range to 270 degrees (typical for knobs)
                    root.rotation-angle = -135deg + ((root.value - root.min-value) / (root.max-value - root.min-value)) * 270deg;
                }

                // Emit callback
                root.value-changed(root.value);
            }
        }

        scroll-event(event) => {
            // Handle scroll wheel (convert delta-y from length to float)
            root.value = root.value - (event.delta-y / 1px) * root.scroll-sensitivity;

            // Clamp value if in bounded mode
            if (!root.is-infinite) {
                root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
            }

            // Convert value to rotation angle
            if (root.is-infinite) {
                // Infinite rotation
                root.rotation-angle = root.value * 1deg;
            } else {
                // Bounded rotation: map value range to 270 degrees
                root.rotation-angle = -135deg + ((root.value - root.min-value) / (root.max-value - root.min-value)) * 270deg;
            }

            // Emit callback
            root.value-changed(root.value);
            return accept;
        }
    }
}