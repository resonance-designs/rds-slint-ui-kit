/**
 * A reusable set of Slint UI components to use in your projects.
 * Copyright (C) 2026 Richard Bakos @ Resonance Designs.
 * Author: Richard Bakos <info@resonancedesigns.dev>
 * Website: https://resonancedesigns.dev
 * Version: 0.1.0
 */

export component RDSSelectButton {
    in property <string> label;
    in property <bool> active;
    callback clicked();

    width: 80px;
    height: 28px;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: root.active ? #8023d6 : #1c1c22;
        border-radius: 6px;
        border-color: root.active ? #b07cff : #2a2a35;
        border-width: 1px;

        Text {
            text: root.label;
            color: #f6f1ff;
            font-size: 12px;
            horizontal-alignment: center;
            vertical-alignment: center;
        }

        TouchArea {
            clicked => root.clicked();
        }
    }

}

export component RDSSequencerCell {
    in property <bool> active;
    in property <bool> current;
    callback clicked();

    width: 20px;
    height: 20px;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: root.current ? #ffffff : (root.active ? #c53bff : #2a2a35);
        border-radius: 2px;
        border-color: #3a3a45;
        border-width: 1px;

        TouchArea {
            clicked => root.clicked();
        }
    }
}

export component RDSVUMeter {
    in property <float> level;
    in property <color> fill-color: #00ff00;

    width: 140px;
    height: 10px;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: #1a1a22;
        border-radius: 4px;
        border-color: #2a2a35;
        border-width: 1px;

        Rectangle {
            width: Math.max(4px, root.level * parent.width);
            height: parent.height;
            background: root.fill-color;
            border-radius: 4px;
        }
    }
}

export component RDSVertVUMeter {
    in property <float> level;
    in property <color> fill-color: #00ff00;

    width: 12px;
    height: 88px;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: #1a1a22;
        border-radius: 4px;
        border-color: #2a2a35;
        border-width: 1px;

        Rectangle {
            width: parent.width;
            height: Math.max(2px, root.level * parent.height);
            y: parent.height - self.height;
            background: root.fill-color;
            border-radius: 4px;
        }
    }
}

export component RDSCircleToggle {
    in property <bool> active;
    callback clicked();

    width: 14px;
    height: 14px;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: root.active ? #c53bff : #2a2a35;
        border-radius: 999px;
        border-color: root.active ? #e3c1ff : #3a3a45;
        border-width: 1px;

        TouchArea {
            clicked => root.clicked();
        }
    }
}

/*
Component: RDSKnob
Description: A rotary knob component that supports both bounded and infinite rotation modes.
Public properties:
- value: float - Current value
- rotation-angle: angle - Current rotation angle
- size: length - Size of the knob (width and height)
- indicator-position: length - Distance from center to indicator (radius)
- sensitivity: float - Adjust this to change rotation speed
- scroll-sensitivity: float - Sensitivity for scroll wheel
- min-value: float - Minimum value (set equal to max-value for infinite mode)
- max-value: float - Maximum value (set equal to min-value for infinite mode)

Example usage:

RDSKnob {
    size: 60px;
    indicator-position: 20px;
    sensitivity: 0.8;
    min-value: 0;
    max-value: 127;
}
*/
export component RDSKnob inherits Rectangle {
    // Public properties
    in-out property <float> value: 0; // Current value
    in-out property <angle> rotation-angle: 0deg; // Current rotation angle
    in-out property <length> size: 60px; // Size of the knob (width and height)
    in-out property <length> indicator-position: 15px; // Distance from center to indicator (radius)
    in-out property <float> sensitivity: 0.5; // Change rotation speed
    in-out property <float> scroll-sensitivity: 1.0; // Sensitivity for scroll wheel

    // Range properties - set min-value == max-value for infinite mode
    in-out property <float> min-value: 0;
    in-out property <float> max-value: 0; // 0 means infinite (or set equal to min-value)

    callback value-changed(float); // Callback when value changes

    // Private properties for drag tracking
    private property <length> drag-start-y: 0px;
    private property <float> drag-start-value: 0;

    // Helper property to check if infinite mode
    private property <bool> is-infinite: root.min-value == root.max-value;

    width: root.size;
    height: root.size;
    background: @linear-gradient(180deg, #4B4B4B 0%, #202020 100%);
    border-radius: root.width / 2;
    border-width: 2px;
    border-color: @linear-gradient(180deg, #606060 0%, #0E0E0E 100%);

    // Position/value indicator - size scales with knob size
    indicator := Rectangle {
        width: root.size / 6; // Proportional to knob size
        height: root.size / 6;
        // Calculate position based on rotation angle and indicator-position
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: @linear-gradient(180deg, #202020 0%, #4B4B4B 100%);
        border-radius: self.width / 2;
        border-width: 1px;
        border-color: @linear-gradient(180deg, #0E0E0E 0%, #606060 100%);
    }

    // Touch area for interaction
    touch := TouchArea {
        pointer-event(event) => {
            if (event.button == PointerEventButton.left) {
                if (event.kind == PointerEventKind.down) {
                    root.drag-start-y = self.mouse-y;
                    root.drag-start-value = root.value;
                }
            }
        }

        moved => {
            if (self.pressed) {
                // Calculate delta from drag start (convert length to float by dividing by 1px)
                root.value = root.drag-start-value + (root.drag-start-y - self.mouse-y) / 1px * root.sensitivity;

                // Clamp value if in bounded mode
                if (!root.is-infinite) {
                    root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
                }

                // Convert value to rotation angle
                if (root.is-infinite) {
                    // Infinite rotation
                    root.rotation-angle = root.value * 1deg;
                } else {
                    // Bounded rotation: map value range to 270 degrees (typical for knobs)
                    root.rotation-angle = -135deg + ((root.value - root.min-value) / (root.max-value - root.min-value)) * 270deg;
                }

                // Emit callback
                root.value-changed(root.value);
            }
        }

        scroll-event(event) => {
            // Handle scroll wheel (convert delta-y from length to float)
            root.value = root.value - (event.delta-y / 1px) * root.scroll-sensitivity;

            // Clamp value if in bounded mode
            if (!root.is-infinite) {
                root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
            }

            // Convert value to rotation angle
            if (root.is-infinite) {
                // Infinite rotation
                root.rotation-angle = root.value * 1deg;
            } else {
                // Bounded rotation: map value range to 270 degrees
                root.rotation-angle = -135deg + ((root.value - root.min-value) / (root.max-value - root.min-value)) * 270deg;
            }

            // Emit callback
            root.value-changed(root.value);
            return accept;
        }
    }
}
